#!/usr/bin/env python
# version: 0.3
import xmpp, time, xmlrpclib, os, sys, re, os, difflib, smtplib, string, datetime
from email.MIMEText import MIMEText

errMsg = 'Usage: ' + sys.argv[0] + ' [queue ID]'
testres = len(sys.argv)
if testres < 2:
 print errMsg
 sys.exit(1)

queue = sys.argv[1]

sys.path.append('/opt/oplog/conf')
import oplog
import opdb

# set up handler for emailing errors
def errmailer(subtype, errString):
  subject="opLog Error: " + subtype
  server = smtplib.SMTP(oplog.mailhost)
  msg = MIMEText(errString)
  msg["Subject"] = subject
  msg["From"]    = oplog.mailfrom
  msg["To"]      = oplog.mailerrto

  server.sendmail(oplog.mailfrom, [oplog.mailerrto], msg.as_string())
  server.quit()

# as the soap service what the last message ID is
server = xmlrpclib.Server(oplog.baseurl + 'cgi-bin/oplog_server.py')
lastmsg = server.getlastmsg(queue)[0][0]

# get the old last message and update it with the new last message
opdb = opdb.opdb()
sql = "select lastmsg from xmppusherlm where queue = %d" % (int(queue))
currentmsg = opdb.select(sql)[0][0]
sql = "update xmppusherlm set lastmsg=%d where queue=%s" % (int(lastmsg), int(queue))
opdb.insert(sql)
opdb.close()

# if the cached message ID and message ID from the soap service don't match
# construct a list of all new messages
if int(currentmsg) != lastmsg:
    newrange = []
    for i in range((int(currentmsg) + 1),lastmsg):
        newrange.append(i)
    # if there are more than 10 messages, only get the last 10
    # I don't want to get TOTALLY swamped
    if len(newrange) > 10:
        lowrange = lastmsg - 10
    else:
        lowrange = lastmsg - len(newrange)
    # get the subject of all the new messages up to 10
    for i in range(lowrange, lastmsg + 1):
        foo = server.getsubject(queue, str(i))

	# XMPP addition

	# if I'm using a stakeholder DB, get the list of addresses I send to
        if oplog.notify_db_enabled == "true":
	  import MySQLdb
	  if oplog.notify_db_port == "3306":
	    conn = MySQLdb.connect(host=oplog.notify_db_host, user=oplog.notify_db_username, passwd=oplog.notify_db_password, db=oplog.notify_db_name)
	  else:
	    conn = MySQLdb.connect(host=oplog.notify_db_host, port=oplog.notify_db_port, user=oplog.notify_db_username, passwd=oplog.notify_db_password, db=oplog.notify_db_name)
	  curs = conn.cursor()
	  curs.execute("select stakeholder from stakeholders where stype='xmppnotify' and skey='ilog'")
	  xmpp_notify_list = curs.fetchall()
	  conn.close()
	# or from a the list in oplog.py
        else:
	  xmpp_notify_list = oplog.xmpp_notified[int(queue)]
	
	# then send the message to each 
	for xmppnotified in xmpp_notify_list:
	  if oplog.notify_db_enabled == "true":
	    tojid=str(xmppnotified[0])
	  else:
	    tojid=str(xmppnotified)
	  text = "%s \n%scgi-bin/index.py?action=show&queue=%s&msgid=%s" % (foo[0][0],oplog.baseurl,queue,str(i))
	  jid=xmpp.protocol.JID(oplog.xmpp_username)
	  cl=xmpp.Client(jid.getDomain(),debug=[])

          #push stdout to /dev/null to avoid weird warning due to DNS
          saveout = sys.stdout
          sys.stdout = open('/dev/null', 'w')
          if oplog.xmpp_security == 'T':
                con=cl.connect(secure=1)
          else:
                con=cl.connect()
          #re-enable stdout
          sys.stdout.close()
          sys.stdout = saveout

	  # if there are problems send that info the error handler
	  if not con:
	      errmailer('XMPP transmit error','could not connect!')
	      sys.exit()
	  auth=cl.auth(jid.getNode(),oplog.xmpp_password,sasl=oplog.xmpp_sasl)
	  if not auth:
	      errmailer('XMPP transmit error','could not authenticate!')
	      sys.exit()
	  id=cl.send(xmpp.protocol.Message(tojid,text))
	  cl.disconnect()
